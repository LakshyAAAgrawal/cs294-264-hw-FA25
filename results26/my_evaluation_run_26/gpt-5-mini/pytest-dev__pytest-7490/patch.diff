diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py
index 560548aea..8b2691db4 100644
--- a/src/_pytest/nodes.py
+++ b/src/_pytest/nodes.py
@@ -257,30 +257,39 @@ class Node(metaclass=NodeMeta):
             item = item.parent
         chain.reverse()
         return chain
-
-    def add_marker(
-        self, marker: Union[str, MarkDecorator], append: bool = True
-    ) -> None:
-        """dynamically add a marker object to the node.
-
-        :type marker: ``str`` or ``pytest.mark.*``  object
-        :param marker:
-            ``append=True`` whether to append the marker,
-            if ``False`` insert at position ``0``.
-        """
-        from _pytest.mark import MARK_GEN
-
-        if isinstance(marker, MarkDecorator):
-            marker_ = marker
-        elif isinstance(marker, str):
-            marker_ = getattr(MARK_GEN, marker)
-        else:
-            raise ValueError("is not a string or pytest.mark.* Marker")
-        self.keywords[marker_.name] = marker_
-        if append:
-            self.own_markers.append(marker_.mark)
-        else:
-            self.own_markers.insert(0, marker_.mark)
+def add_marker(
+    self, marker: Union[str, MarkDecorator], append: bool = True
+) -> None:
+    """dynamically add a marker object to the node.
+
+    :type marker: ``str`` or ``pytest.mark.*``  object
+    :param marker:
+        ``append=True`` whether to append the marker,
+        if ``False`` insert at position ``0``.
+    """
+    from _pytest.mark import MARK_GEN
+
+    if isinstance(marker, MarkDecorator):
+        marker_ = marker
+    elif isinstance(marker, str):
+        marker_ = getattr(MARK_GEN, marker)
+    else:
+        raise ValueError("is not a string or pytest.mark.* Marker")
+    self.keywords[marker_.name] = marker_
+    if append:
+        self.own_markers.append(marker_.mark)
+    else:
+        self.own_markers.insert(0, marker_.mark)
+
+    # Invalidate cached xfail evaluation so dynamically added xfail marks
+    # are considered during the test run (see pytest issue #7486).
+    try:
+        from _pytest.skipping import xfailed_key
+    except Exception:
+        xfailed_key = None
+    if xfailed_key is not None:
+        # remove cached evaluation if present
+        self._store.pop(xfailed_key, None)
 
     def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:
         """