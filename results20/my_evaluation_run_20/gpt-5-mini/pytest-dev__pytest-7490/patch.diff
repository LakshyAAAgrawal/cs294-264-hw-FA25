diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py
index 560548aea..b60dd0248 100644
--- a/src/_pytest/nodes.py
+++ b/src/_pytest/nodes.py
@@ -245,9 +245,7 @@ class Node(metaclass=NodeMeta):
         pass
 
     def teardown(self) -> None:
-        pass
-
-    def listchain(self) -> List["Node"]:
+def listchain(self) -> List["Node"]:
         """ return list of all parent collectors up to self,
             starting from root of collection tree. """
         chain = []
@@ -257,8 +255,7 @@ class Node(metaclass=NodeMeta):
             item = item.parent
         chain.reverse()
         return chain
-
-    def add_marker(
+def add_marker(
         self, marker: Union[str, MarkDecorator], append: bool = True
     ) -> None:
         """dynamically add a marker object to the node.
@@ -282,6 +279,26 @@ class Node(metaclass=NodeMeta):
         else:
             self.own_markers.insert(0, marker_.mark)
 
+        # Invalidate any cached skip/xfail evaluation stored on this node so that
+        # markers added dynamically during setup/call are picked up by the
+        # xfail/skip evaluation logic (see _pytest/skipping.py).
+        try:
+            # Import locally to avoid circular imports at module import time.
+            from _pytest.skipping import xfailed_key, skipped_by_mark_key
+        except Exception:
+            # If skipping isn't available for some reason, do nothing.
+            return
+
+        try:
+            del self._store[xfailed_key]
+        except KeyError:
+            pass
+
+        if append:
+            self.own_markers.append(marker_.mark)
+        else:
+            self.own_markers.insert(0, marker_.mark)
+
     def iter_markers(self, name: Optional[str] = None) -> Iterator[Mark]:
         """
         :param name: if given, filter the results by the name attribute