diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py
index fe52d881d..0062192d2 100644
--- a/sphinx/domains/cpp.py
+++ b/sphinx/domains/cpp.py
@@ -876,6 +876,24 @@ class ASTCharLiteral(ASTLiteral):
     def get_id(self, version: int) -> str:
         return self.type + str(self.value)
 
+    def describe_signature(self, signode: TextElement, mode: str,
+                           env: "BuildEnvironment", symbol: "Symbol") -> None:
+class ASTUserDefinedLiteral(ASTLiteral):
+    """Represents a user-defined literal formed by a literal followed by an
+    identifier suffix (e.g. 12_k, 1.0q_J, "str"s)."""
+    def __init__(self, base: ASTLiteral, suffix: str) -> None:
+        self.base = base
+        self.suffix = suffix
+
+    def _stringify(self, transform: StringifyTransform) -> str:
+        # display as base followed by suffix (no separating space)
+        return transform(self.base) + self.suffix
+
+    def get_id(self, version: int) -> str:
+        # incorporate the base id and the suffix (prefix with UD to avoid
+        # accidental collisions with other id forms)
+        return self.base.get_id(version) + "_UD" + self.suffix
+
     def describe_signature(self, signode: TextElement, mode: str,
                            env: "BuildEnvironment", symbol: "Symbol") -> None:
         txt = str(self)
@@ -893,6 +911,10 @@ class ASTThisLiteral(ASTExpression):
                            env: "BuildEnvironment", symbol: "Symbol") -> None:
         signode.append(nodes.Text("this"))
 
+    def describe_signature(self, signode: TextElement, mode: str,
+                           env: "BuildEnvironment", symbol: "Symbol") -> None:
+        signode.append(nodes.Text("this"))
+
 
 class ASTFoldExpr(ASTExpression):
     def __init__(self, leftExpr: ASTExpression,
@@ -4650,20 +4672,27 @@ class DefinitionParser(BaseParser):
         #  | string-literal
         #  | boolean-literal -> "false" | "true"
         #  | pointer-literal -> "nullptr"
-        #  | user-defined-literal
-        self.skip_ws()
-        if self.skip_word('nullptr'):
-            return ASTPointerLiteral()
-        if self.skip_word('true'):
-            return ASTBooleanLiteral(True)
-        if self.skip_word('false'):
-            return ASTBooleanLiteral(False)
-        for regex in [float_literal_re, binary_literal_re, hex_literal_re,
-                      integer_literal_re, octal_literal_re]:
-            pos = self.pos
-            if self.match(regex):
-                while self.current_char in 'uUlLfF':
-                    self.pos += 1
+self.skip_ws()
+          if self.skip_word('nullptr'):
+              return ASTPointerLiteral()
+          if self.skip_word('true'):
+              return ASTBooleanLiteral(True)
+          if self.skip_word('false'):
+              return ASTBooleanLiteral(False)
+          for regex in [float_literal_re, binary_literal_re, hex_literal_re,
+                        integer_literal_re, octal_literal_re]:
+              pos = self.pos
+              if self.match(regex):
+                  # consume C/C++ builtin suffix letters like u, U, l, L, f, F
+                  while self.current_char in 'uUlLfF':
+                      self.pos += 1
+                  base = ASTNumberLiteral(self.definition[pos:self.pos])
+                  # If an identifier immediately follows the literal (no whitespace),
+                  # treat it as a user-defined literal suffix and wrap the base.
+                  if self.match(identifier_re):
+                      suffix = self.matched_text
+                      return ASTUserDefinedLiteral(base, suffix)
+                  return base
                 return ASTNumberLiteral(self.definition[pos:self.pos])
 
         string = self._parse_string()