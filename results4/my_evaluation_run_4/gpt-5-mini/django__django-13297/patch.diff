Root cause:
Values in the view's kwargs can be SimpleLazyObject instances (lazy wrappers). Passing a lazy object directly into a database lookup (e.g., Account.objects.get/filter) can raise "Error binding parameter 0 - probably unsupported type" because the DB driver doesn't know how to handle the wrapper.

Fixes (pick one):

1) Coerce to str (simplest)
class OfferView(TemplateView):
    template_name = "offers/offer.html"
    def get_context_data(self, **kwargs):
        offer_slug = str(kwargs.get("offer_slug", ""))
        offer = get_object_or_404(Account, slug=offer_slug)
        return {"offer": offer, "offer_slug": offer_slug}

2) Use Django's force_str for explicit intent
from django.utils.encoding import force_str

class OfferView(TemplateView):
    template_name = "offers/offer.html"
    def get_context_data(self, **kwargs):
        offer_slug = force_str(kwargs.get("offer_slug", ""))
        offer = get_object_or_404(Account, slug=offer_slug)
        return {"offer": offer, "offer_slug": offer_slug}

Notes and recommendations:
- Using str(...) or force_str(...) evaluates the SimpleLazyObject and yields the underlying value; this is safe and common when supplying values into DB queries.
- If you have many places where lazy values are passed into DB lookups, centralize handling (e.g., coerce in a small helper or ensure the resolver/middleware returns concrete values).
- If you want to be defensive, check isinstance(value, SimpleLazyObject) before coercing, but str/force_str is fine for most cases.
- Test: add a unit/integration test that simulates a request with a lazy-wrapped URL kwarg to ensure lookups succeed.

If you want, I can:
- Search the codebase for other places using kwargs values in DB queries and propose batch fixes.
- Replace occurrences automatically with a safe helper (small scoped edits).

No changes detected to generate a patch.