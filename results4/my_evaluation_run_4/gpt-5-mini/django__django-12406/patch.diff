diff --git a/django/forms/models.py b/django/forms/models.py
index dafc11f995..d2c913f86d 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -13,63 +13,54 @@ from django.forms.forms import BaseForm, DeclarativeFieldsMetaclass
 from django.forms.formsets import BaseFormSet, formset_factory
 from django.forms.utils import ErrorList
 from django.forms.widgets import (
-    HiddenInput, MultipleHiddenInput, SelectMultiple,
+    HiddenInput, MultipleHiddenInput, SelectMultiple, RadioSelect,
 )
-from django.utils.text import capfirst, get_text_list
-from django.utils.translation import gettext, gettext_lazy as _
-
-__all__ = (
-    'ModelForm', 'BaseModelForm', 'model_to_dict', 'fields_for_model',
-    'ModelChoiceField', 'ModelMultipleChoiceField', 'ALL_FIELDS',
-    'BaseModelFormSet', 'modelformset_factory', 'BaseInlineFormSet',
-    'inlineformset_factory', 'modelform_factory',
-)
-
-ALL_FIELDS = '__all__'
-
-
-def construct_instance(form, instance, fields=None, exclude=None):
-    """
-    Construct and return a model instance from the bound ``form``'s
-    ``cleaned_data``, but do not save the returned instance to the database.
-    """
-    from django.db import models
-    opts = instance._meta
-
-    cleaned_data = form.cleaned_data
-    file_field_list = []
-    for f in opts.fields:
-        if not f.editable or isinstance(f, models.AutoField) \
-                or f.name not in cleaned_data:
-            continue
-        if fields is not None and f.name not in fields:
-            continue
-        if exclude and f.name in exclude:
-            continue
-        # Leave defaults for fields that aren't in POST data, except for
-        # checkbox inputs because they don't appear in POST data if not checked.
-        if (
-            f.has_default() and
-            form[f.name].field.widget.value_omitted_from_data(form.data, form.files, form.add_prefix(f.name)) and
-            cleaned_data.get(f.name) in form[f.name].field.empty_values
-        ):
-            continue
-        # Defer saving file-type fields until after the other fields, so a
-        # callable upload_to can use the values from other fields.
-        if isinstance(f, models.FileField):
-            file_field_list.append(f)
-        else:
-            f.save_form_data(instance, cleaned_data[f.name])
-
-    for f in file_field_list:
-        f.save_form_data(instance, cleaned_data[f.name])
-
-    return instance
 
-
-# ModelForms #################################################################
-
-def model_to_dict(instance, fields=None, exclude=None):
+    def ModelChoiceIterator:
+        def __init__(self, field):
+            self.field = field
+            self.queryset = field.queryset
+
+        def __iter__(self):
+            if self.field.empty_label is not None:
+                yield ("", self.field.empty_label)
+            queryset = self.queryset
+            # Can't use iterator() when queryset uses prefetch_related()
+            if not queryset._prefetch_related_lookups:
+                queryset = queryset.iterator()
+            for obj in queryset:
+                yield self.choice(obj)
+
+    class ModelChoiceField(ChoiceField):
+        """A ChoiceField whose choices are a model QuerySet."""
+        # This class is a subclass of ChoiceField for purity, but it doesn't
+        # actually use any of ChoiceField's implementation.
+        default_error_messages = {
+            'invalid_choice': _('Select a valid choice. That choice is not one of'
+                                ' the available choices.'),
+        }
+        iterator = ModelChoiceIterator
+
+        def __init__(self, queryset, *, empty_label="---------",
+                     required=True, widget=None, label=None, initial=None,
+                     help_text='', to_field_name=None, limit_choices_to=None,
+                     blank=False, **kwargs):
+            # Call Field instead of ChoiceField __init__() because we don't need
+            # ChoiceField.__init__().
+            Field.__init__(
+                self, required=required, widget=widget, label=label,
+                initial=initial, help_text=help_text, **kwargs
+            )
+            if (
+                (required and initial is not None) or
+                (isinstance(self.widget, RadioSelect) and not blank)
+            ):
+                self.empty_label = None
+            else:
+                self.empty_label = empty_label
+            self.queryset = queryset
+            self.limit_choices_to = limit_choices_to   # limit the queryset later.
+            self.to_field_name = to_field_name
     """
     Return a dict containing the data in ``instance`` suitable for passing as
     a Form's ``initial`` keyword argument.