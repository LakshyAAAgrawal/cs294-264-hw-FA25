diff --git a/sympy/physics/units/unitsystem.py b/sympy/physics/units/unitsystem.py
index a436880c4b..4c158e0f1a 100644
--- a/sympy/physics/units/unitsystem.py
+++ b/sympy/physics/units/unitsystem.py
@@ -94,40 +94,7 @@ def get_unit_system(unit_system):
 
         if unit_system not in UnitSystem._unit_systems:
             raise ValueError(
-                "Unit system is not supported. Currently"
-                "supported unit systems are {}".format(
-                    ", ".join(sorted(UnitSystem._unit_systems))
-                )
-            )
-
-        return UnitSystem._unit_systems[unit_system]
-
-    @staticmethod
-    def get_default_unit_system():
-        return UnitSystem._unit_systems["SI"]
-
-    @property
-    def dim(self):
-        """
-        Give the dimension of the system.
-
-        That is return the number of units forming the basis.
-        """
-        return len(self._base_units)
-
-    @property
-    def is_consistent(self):
-        """
-        Check if the underlying dimension system is consistent.
-        """
-        # test is performed in DimensionSystem
-        return self.get_dimension_system().is_consistent
-
-    @property
-    def derived_units(self) -> tDict[Dimension, Quantity]:
-        return self._derived_units
-
-    def get_dimensional_expr(self, expr):
+def get_dimensional_expr(self, expr):
         from sympy.physics.units import Quantity
         if isinstance(expr, Mul):
             return Mul(*[self.get_dimensional_expr(i) for i in expr.args])
@@ -170,6 +137,40 @@ def _collect_factor_and_dimension(self, expr):
             if self.get_dimension_system().is_dimensionless(exp_dim):
                 exp_dim = 1
             return factor ** exp_factor, dim ** (exp_factor * exp_dim)
+        elif isinstance(expr, Add):
+            factor, dim = self._collect_factor_and_dimension(expr.args[0])
+            for addend in expr.args[1:]:
+                addend_factor, addend_dim = \
+                    self._collect_factor_and_dimension(addend)
+                if not self.get_dimension_system().equivalent_dims(dim, addend_dim):
+                    raise ValueError(
+                        'Dimension of "{}" is {}, '
+                        'but it should be {}'.format(
+                            addend, addend_dim, dim))
+                factor += addend_factor
+            return factor, dim
+        elif isinstance(expr, Derivative):
+            factor, dim = self._collect_factor_and_dimension(expr.args[0])
+            for independent, count in expr.variable_count:
+                ifactor, idim = self._collect_factor_and_dimension(independent)
+                factor /= ifactor**count
+                dim /= idim**count
+            return factor, dim
+        elif isinstance(expr, Function):
+            fds = [self._collect_factor_and_dimension(arg) for arg in expr.args]
+            dims = [Dimension(1) if self.get_dimension_system().is_dimensionless(d[1]) else d[1] for d in fds]
+            return (expr.func(*(f[0] for f in fds)), *dims)
+        elif isinstance(expr, Dimension):
+            return S.One, expr
+        else:
+            return expr, Dimension(1)
+            return factor, dimension
+        elif isinstance(expr, Pow):
+            factor, dim = self._collect_factor_and_dimension(expr.base)
+            exp_factor, exp_dim = self._collect_factor_and_dimension(expr.exp)
+            if self.get_dimension_system().is_dimensionless(exp_dim):
+                exp_dim = 1
+            return factor ** exp_factor, dim ** (exp_factor * exp_dim)
         elif isinstance(expr, Add):
             factor, dim = self._collect_factor_and_dimension(expr.args[0])
             for addend in expr.args[1:]: