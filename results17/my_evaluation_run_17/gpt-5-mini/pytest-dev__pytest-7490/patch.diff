diff --git a/src/_pytest/nodes.py b/src/_pytest/nodes.py
index 560548aea..9dd904b29 100644
--- a/src/_pytest/nodes.py
+++ b/src/_pytest/nodes.py
@@ -204,27 +204,40 @@ class Node(metaclass=NodeMeta):
 
     def warn(self, warning: "PytestWarning") -> None:
         """Issue a warning for this item.
-
-        Warnings will be displayed after the test session, unless explicitly suppressed
-
-        :param Warning warning: the warning instance to issue. Must be a subclass of PytestWarning.
-
-        :raise ValueError: if ``warning`` instance is not a subclass of PytestWarning.
-
-        Example usage:
-
-        .. code-block:: python
-
-            node.warn(PytestWarning("some message"))
-
+def add_marker(
+        self, marker: Union[str, MarkDecorator], append: bool = True
+    ) -> None:
+        """dynamically add a marker object to the node.
+    
+        :type marker: ``str`` or ``pytest.mark.*``  object
+        :param marker:
+            ``append=True`` whether to append the marker,
+            if ``False`` insert at position ``0``.
         """
-        from _pytest.warning_types import PytestWarning
-
-        if not isinstance(warning, PytestWarning):
-            raise ValueError(
-                "warning must be an instance of PytestWarning or subclass, got {!r}".format(
-                    warning
-                )
+        from _pytest.mark import MARK_GEN
+    
+        if isinstance(marker, MarkDecorator):
+            marker_ = marker
+        elif isinstance(marker, str):
+            marker_ = getattr(MARK_GEN, marker)
+        else:
+            raise ValueError("is not a string or pytest.mark.* Marker")
+        self.keywords[marker_.name] = marker_
+        if append:
+            self.own_markers.append(marker_.mark)
+        else:
+            self.own_markers.insert(0, marker_.mark)
+    
+        # Invalidate cached xfail evaluation (if present) so dynamically added
+        # xfail/skip marks during test execution are re-evaluated by the skipping
+        # plugin's logic (pytest_runtest_call will re-evaluate when the store
+        # value is None).
+        try:
+            from _pytest.skipping import xfailed_key  # type: ignore
+            self._store[xfailed_key] = None
+        except Exception:
+            # skipping plugin may not be loaded; ignore.
+            pass
             )
         path, lineno = get_fslocation_from_item(self)
         assert lineno is not None