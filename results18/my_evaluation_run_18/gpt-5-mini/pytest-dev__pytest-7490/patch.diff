diff --git a/src/_pytest/skipping.py b/src/_pytest/skipping.py
index 335e10996..814f92cd7 100644
--- a/src/_pytest/skipping.py
+++ b/src/_pytest/skipping.py
@@ -209,40 +209,45 @@ def evaluate_xfail_marks(item: Item) -> Optional[Xfail]:
             conditions = (mark.kwargs["condition"],)
 
         # Unconditional.
-        if not conditions:
-            reason = mark.kwargs.get("reason", "")
-            return Xfail(reason, run, strict, raises)
-
-        # If any of the conditions are true.
-        for condition in conditions:
-            result, reason = evaluate_condition(item, mark, condition)
-            if result:
-                return Xfail(reason, run, strict, raises)
-
-    return None
-
-
-# Whether skipped due to skip or skipif marks.
-skipped_by_mark_key = StoreKey[bool]()
-# Saves the xfail mark evaluation. Can be refreshed during call if None.
-xfailed_key = StoreKey[Optional[Xfail]]()
-unexpectedsuccess_key = StoreKey[str]()
-
-
-@hookimpl(tryfirst=True)
-def pytest_runtest_setup(item: Item) -> None:
-    item._store[skipped_by_mark_key] = False
-
-    skipped = evaluate_skip_marks(item)
-    if skipped:
-        item._store[skipped_by_mark_key] = True
-        skip(skipped.reason)
-
-    if not item.config.option.runxfail:
+@hookimpl(hookwrapper=True)
+def pytest_runtest_makereport(item: Item, call: CallInfo[None]):
+    outcome = yield
+    rep = outcome.get_result()
+    # Refresh xfail evaluation if it wasn't cached so that marks added
+    # during the call (e.g. via request.node.add_marker) are honored.
+    xfailed = item._store.get(xfailed_key, None)
+    if xfailed is None:
         item._store[xfailed_key] = xfailed = evaluate_xfail_marks(item)
-        if xfailed and not xfailed.run:
-            xfail("[NOTRUN] " + xfailed.reason)
 
+    # unittest special case, see setting of unexpectedsuccess_key
+    if unexpectedsuccess_key in item._store and rep.when == "call":
+        reason = item._store[unexpectedsuccess_key]
+        if reason:
+            rep.longrepr = "Unexpected success: {}".format(reason)
+        else:
+            rep.longrepr = "Unexpected success"
+        rep.outcome = "failed"
+    elif item.config.option.runxfail:
+        pass  # don't interfere
+    elif call.excinfo and isinstance(call.excinfo.value, xfail.Exception):
+        assert call.excinfo.value.msg is not None
+        rep.wasxfail = "reason: " + call.excinfo.value.msg
+        rep.outcome = "skipped"
+    elif not rep.skipped and xfailed:
+        if call.excinfo:
+            raises = xfailed.raises
+            if raises is not None and not isinstance(call.excinfo.value, raises):
+                rep.outcome = "failed"
+            else:
+                rep.outcome = "skipped"
+                rep.wasxfail = xfailed.reason
+        elif call.when == "call":
+            if xfailed.strict:
+                rep.outcome = "failed"
+                rep.longrepr = "[XPASS(strict)] " + xfailed.reason
+            else:
+                rep.outcome = "passed"
+                rep.wasxfail = xfailed.reason
 
 @hookimpl(hookwrapper=True)
 def pytest_runtest_call(item: Item) -> Generator[None, None, None]: