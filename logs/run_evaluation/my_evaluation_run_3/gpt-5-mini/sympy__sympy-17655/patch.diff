Root cause
The expression sympy.sympify(2.0) * point2 is evaluated by SymPy as a Mul object (an Expr) because the Float object's __mul__ returns a Mul. geometry.Point.__add__ expects either a Point or a coordinate sequence and does not special-case Mul objects that wrap a Point, so it raises a GeometryError when given "2.0*Point2D(1,1)".

Workarounds
1) Prefer the commuted form point * scalar when possible:
    point2 * sympy.sympify(2.0)   # works because Point.__mul__ handles scalar on the right

2) Convert the Mul into a point*scalar before adding:
    other = sympy.sympify(2.0)*point2
    if isinstance(other, sympy.Mul):
        # find the Point inside and form point*scalar
        for a in other.args:
            if isinstance(a, ge.Point):
                scalar = other / a   # yields the scalar factor
                break
    result = point1 + (a * scalar)

Monkeypatch (minimal, safe): replace Point.__add__ at runtime to accept scalar*Point Muls
from sympy import geometry as ge
from sympy import Mul
Point = ge.Point

_orig_point_add = Point.__add__

def _patched_point_add(self, other):
    try:
        # try original behavior first
        return _orig_point_add(self, other)
    except ge.GeometryError:
        # handle cases like Mul(scalar, Point)
        if isinstance(other, Mul):
            # find a Point argument inside the Mul
            point_arg = None
            scalar = 1
            for a in other.args:
                if isinstance(a, Point):
                    point_arg = a
                else:
                    scalar = scalar * a
            if point_arg is not None:
                # reorder to point * scalar (Point.__mul__ handles scalar on right)
                return _orig_point_add(self, point_arg * scalar)
        # re-raise if we can't handle it
        raise

# Install the patch
Point.__add__ = _patched_point_add

Example
>>> import sympy
>>> from sympy import geometry as ge
>>> point1 = ge.Point(0,0)
>>> point2 = ge.Point(1,1)
>>> point1 + sympy.sympify(2.0) * point2   # after monkeypatch
Point2D(2.0, 2.0)

Suggested upstream fix
In geometry/point.py (Point.__add__), where it currently tries to construct Point(other) and raises GeometryError on failure, add a small branch that recognizes a Mul whose arguments include a Point (or a Point-like object). Extract the Point argument and the scalar coefficient, reorder to point*scalar and proceed. The monkeypatch above is a direct translation of that approach. This keeps backward compatibility and makes expressions like scalar * Point behave symmetrically with Point * scalar.

Notes
- This is purely a SymPy API convenience/interop issue (Python's left-operand-first dispatch and SymPy's Mul creation cause the mismatch).
- Filing a bug/PR against sympy (with the small unit test demonstrating both orders producing the same result) is recommended.

References / next step
If you want, I can:
- create a minimal unit test for sympy's test suite,
- prepare a suggested patch (diff) for geometry/point.py applying the change described above,
- or apply the monkeypatch into your environment and run a short repro to show it fixes your immediate problem.

Would you like a prepared patch/PR-ready change to geometry/point.py or the unit test only?

No changes detected to generate a patch.