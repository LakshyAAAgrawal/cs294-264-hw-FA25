diff --git a/django/forms/models.py b/django/forms/models.py
index dafc11f995..aeb86bfb1e 100644
--- a/django/forms/models.py
+++ b/django/forms/models.py
@@ -133,14 +133,7 @@ def fields_for_model(model, fields=None, exclude=None, widgets=None,
     ``field_classes`` is a dictionary of model field names mapped to a form
     field class.
 
-    ``apply_limit_choices_to`` is a boolean indicating if limit_choices_to
-    should be applied to a field's queryset.
-    """
-    field_dict = {}
-    ignored = []
-    opts = model._meta
-    # Avoid circular import
-    from django.db.models import Field as ModelField
+from django.db.models import Field as ModelField
     sortable_private_fields = [f for f in opts.private_fields if isinstance(f, ModelField)]
     for f in sorted(chain(opts.concrete_fields, sortable_private_fields, opts.many_to_many)):
         if not getattr(f, 'editable', False):
@@ -151,6 +144,18 @@ def fields_for_model(model, fields=None, exclude=None, widgets=None,
                         f.name, model.__name__)
                 )
             continue
+            if _RadioSelect is not None and issubclass(widget_cls, _RadioSelect) and getattr(f, 'blank', True) is False:
+                kwargs.setdefault('empty_label', None)
+        formfield = f.formfield(**kwargs)
+    elif not callable(formfield_callback):
+        raise TypeError('formfield_callback must be a function or callable')
+    else:
+        formfield = formfield_callback(f, **kwargs)
+                raise FieldError(
+                    "'%s' cannot be specified for %s model form as it is a non-editable field" % (
+                        f.name, model.__name__)
+                )
+            continue
         if fields is not None and f.name not in fields:
             continue
         if exclude and f.name in exclude:
@@ -169,12 +174,24 @@ def fields_for_model(model, fields=None, exclude=None, widgets=None,
             kwargs['error_messages'] = error_messages[f.name]
         if field_classes and f.name in field_classes:
             kwargs['form_class'] = field_classes[f.name]
-
-        if formfield_callback is None:
-            formfield = f.formfield(**kwargs)
-        elif not callable(formfield_callback):
-            raise TypeError('formfield_callback must be a function or callable')
-        else:
+if formfield_callback is None:
+        # If a RadioSelect widget is explicitly provided for a related field
+        # and the model field doesn't allow blank, don't add an empty choice.
+        widget = kwargs.get('widget')
+        if widget is not None:
+            # widget may be a class or an instance
+            widget_cls = widget if isinstance(widget, type) else widget.__class__
+            try:
+                from django.forms.widgets import RadioSelect as _RadioSelect
+            except Exception:
+                _RadioSelect = None
+            if _RadioSelect is not None and issubclass(widget_cls, _RadioSelect) and getattr(f, 'blank', True) is False:
+                kwargs.setdefault('empty_label', None)
+        formfield = f.formfield(**kwargs)
+    elif not callable(formfield_callback):
+        raise TypeError('formfield_callback must be a function or callable')
+    else:
+        formfield = formfield_callback(f, **kwargs)
             formfield = formfield_callback(f, **kwargs)
 
         if formfield: