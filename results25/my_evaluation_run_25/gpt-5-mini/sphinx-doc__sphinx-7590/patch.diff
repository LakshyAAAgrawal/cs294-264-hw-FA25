diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py
index fe52d881d..93b826934 100644
--- a/sphinx/domains/cpp.py
+++ b/sphinx/domains/cpp.py
@@ -4650,7 +4650,6 @@ class DefinitionParser(BaseParser):
         #  | string-literal
         #  | boolean-literal -> "false" | "true"
         #  | pointer-literal -> "nullptr"
-        #  | user-defined-literal
         self.skip_ws()
         if self.skip_word('nullptr'):
             return ASTPointerLiteral()
@@ -4658,22 +4657,42 @@ class DefinitionParser(BaseParser):
             return ASTBooleanLiteral(True)
         if self.skip_word('false'):
             return ASTBooleanLiteral(False)
+            return ASTBooleanLiteral(False)
+
         for regex in [float_literal_re, binary_literal_re, hex_literal_re,
                       integer_literal_re, octal_literal_re]:
             pos = self.pos
             if self.match(regex):
+                # consume standard C/C++ suffixes (u, U, l, L, f, F)
                 while self.current_char in 'uUlLfF':
                     self.pos += 1
+                # user-defined literal suffix: identifier characters starting with letter or underscore
+                if self.current_char is not None and re.match(r'[A-Za-z_]', self.current_char):
+                    while self.current_char is not None and (self.current_char.isalnum() or self.current_char == '_'):
+                        self.pos += 1
+                    return ASTUserDefinedLiteral(self.definition[pos:self.pos])
                 return ASTNumberLiteral(self.definition[pos:self.pos])
-
+        
+        pos = self.pos
         string = self._parse_string()
         if string is not None:
+            # if there's an ud-suffix after the string literal, consume it
+            if self.current_char is not None and re.match(r'[A-Za-z_]', self.current_char):
+                while self.current_char is not None and (self.current_char.isalnum() or self.current_char == '_'):
+                    self.pos += 1
+                return ASTUserDefinedLiteral(self.definition[pos:self.pos])
             return ASTStringLiteral(string)
-
+        
         # character-literal
+        pos = self.pos
         if self.match(char_literal_re):
             prefix = self.last_match.group(1)  # may be None when no prefix
             data = self.last_match.group(2)
+            # if there's an ud-suffix after the character literal, consume it
+            if self.current_char is not None and re.match(r'[A-Za-z_]', self.current_char):
+                while self.current_char is not None and (self.current_char.isalnum() or self.current_char == '_'):
+                    self.pos += 1
+                return ASTUserDefinedLiteral(self.definition[pos:self.pos])
             try:
                 return ASTCharLiteral(prefix, data)
             except UnicodeDecodeError as e:
@@ -4681,8 +4700,8 @@ class DefinitionParser(BaseParser):
             except UnsupportedMultiCharacterCharLiteral:
                 self.fail("Can not handle character literal"
                           " resulting in multiple decoded characters.")
-
-        # TODO: user-defined lit
+        
+        return None
         return None
 
     def _parse_fold_or_paren_expression(self) -> ASTExpression: