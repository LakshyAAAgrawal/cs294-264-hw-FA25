"""
Starter scaffold for the CS 294-264 HW1 ReAct agent.

Students must implement a minimal ReAct agent that:
- Maintains a message history tree (role, content, timestamp, unique_id, parent, children)
- Uses a textual function-call format (see ResponseParser) with rfind-based parsing
- Alternates Reasoning and Acting until calling the tool `finish`
- Supports tools: `run_bash_cmd`, `finish`, and `add_instructions_and_backtrack`

This file intentionally omits core implementations and replaces them with
clear specifications and TODOs.
"""

import time
from typing import List, Callable, Dict, Any

from response_parser import ResponseParser
from llm import LLM
from utils import SWEEnvironment
from utils import SWEEnvironment

class ReactAgent:
    """
    Minimal ReAct agent that:
    - Maintains a message history tree with unique ids
    - Builds the LLM context from the root to current node
    - Registers callable tools with auto-generated docstrings in the system prompt
    - Runs a Reason-Act loop until `finish` is called or MAX_STEPS is reached
    """

    def __init__(self, name: str, parser: ResponseParser, llm: LLM, env: SWEEnvironment):
        self.name: str = name
        self.parser = parser
        self.llm = llm
        self.env = env

        # Message tree storage
        self.id_to_message: List[Dict[str, Any]] = []
        self.root_message_id: int = -1
        self.current_message_id: int = -1

        # Registered tools
        self.function_map: Dict[str, Callable] = {}

        # Create required root nodes
        # TODO(student): The root must be a system node with content:
        # "You are a Smart ReAct agent." plus tool list and response format.
        # Also create a user node (task) and an instruction node as specified in the assignment.
        raise NotImplementedError("Initialize system/user/instruction nodes per the spec")
      
        # TODO(student): Initialize with a list of functions 
        self.add_functions([self.run_bash_cmd])
        self.add_functions([self.finish])
        # ....
    

    def add_functions(self, tools: List[Callable]):
        """
        Add callable tools to the agent's function map.

        The system prompt must include tool descriptions that cover:
        - The signature of each tool
        - The docstring of each tool
        """
        # TODO(student): Register tools and construct tool descriptions for the system prompt.
        raise NotImplementedError("add_functions must be implemented by the student")

    def add_message(self, role: str, content: str) -> int:
        """
        Create a new message and add it to the tree.

        The message must include fields: role, content, timestamp, unique_id, parent, children.
        Maintain a pointer to the current node and the root node.
        """
        # TODO(student): Implement message tree creation and linking.
        raise NotImplementedError("add_message must be implemented by the student")

    def set_message_content(self, message_id: int, content: str) -> None:
        """Update message content by id."""
        # TODO(student): Implement message content update.
        raise NotImplementedError("set_message_content must be implemented by the student")

    def get_context(self) -> str:
        """
        Build the full LLM context by walking from the root to the current message.
        """
        # TODO(student): Implement context construction.
        raise NotImplementedError("get_context must be implemented by the student")

    # -------------------- REQUIRED TOOLS --------------------
    def run_bash_cmd(self, command: str):
        """Run the command in a bash shell and return the output or throw a ValueError exception if the process returns non-zero exit code

        Args;
            command (str): the shell command to run

        Returns:
            The output of running the shell command
        """
        return self.env.execute(command)

    def finish(self, result: str):
        """The agent must call this function with the final result when it has solved the given task. The function calls "git add -A and git diff --cached" to generate a patch and returns the patch as submission.

        Args: 
            result (str); the result generated by the agent

        Returns:
            The result passed as an argument.  The result is then returned by the agent's run method.
        """
        try:
            patch_output = self.env.execute("git add -A && git diff --cached")
            if patch_output.strip():
                return patch_output
            else:
                return f"{result}\n\nNo changes detected to generate a patch."
        except Exception as e:
            return f"{result}\n\nError running git commands: {e}"

    def add_instructions_and_backtrack(self, instructions: str, at_message_id: int):
        """
        The agent should call this function if it is making too many mistakes or is stuck.

        The function changes the content of the instruction node with 'instructions' and
        backtracks at the node with id 'at_message_id'. Backtracking means the current node
        pointer moves to the specified node and subsequent context is rebuilt from there.

        Returns a short success string.
        """
        # TODO(student): Implement instruction update and backtracking logic.
        raise NotImplementedError("add_instructions_and_backtrack must be implemented by the student")

    # -------------------- MAIN LOOP --------------------
    def run(self, task: str, max_steps: int) -> str:
        """
        Run the agent's main ReAct loop:
        - Set the user prompt
        - Loop up to max_steps (<= 100):
            - Build context from the message tree
            - Query the LLM
            - Parse a single function call at the end (see ResponseParser)
            - Execute the tool
            - Append tool result to the tree
            - If `finish` is called, return the final result
        """
        # TODO(student): Implement the Reason-Act loop per the assignment, including error handling.
        raise NotImplementedError("run must be implemented by the student")


if __name__ == "__main__":
    # Optional: students can add their own quick manual test here.
    pass
