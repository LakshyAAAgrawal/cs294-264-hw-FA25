diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py
index fe52d881d..22e81defb 100644
--- a/sphinx/domains/cpp.py
+++ b/sphinx/domains/cpp.py
@@ -882,6 +882,27 @@ class ASTCharLiteral(ASTLiteral):
         signode.append(nodes.Text(txt, txt))
 
 
+  class ASTUserDefinedLiteral(ASTLiteral):
+      """Represents a literal with a user-defined-literal suffix, e.g. 123_km or "s"_mysuf."""
+      def __init__(self, literal: ASTLiteral, suffix: str) -> None:
+          self.literal = literal
+          self.suffix = suffix
+
+      def _stringify(self, transform: StringifyTransform) -> str:
+          return transform(self.literal) + self.suffix
+
+      def get_id(self, version: int) -> str:
+          try:
+              base = self.literal.get_id(version)
+          except Exception:
+              base = str(self.literal)
+          return "%s_udl_%s" % (base, self.suffix)
+
+      def describe_signature(self, signode: TextElement, mode: str,
+                             env: "BuildEnvironment", symbol: "Symbol") -> None:
+          txt = str(self)
+          signode.append(nodes.Text(txt, txt))
+
 class ASTThisLiteral(ASTExpression):
     def _stringify(self, transform: StringifyTransform) -> str:
         return "this"
@@ -4659,18 +4680,27 @@ class DefinitionParser(BaseParser):
         if self.skip_word('false'):
             return ASTBooleanLiteral(False)
         for regex in [float_literal_re, binary_literal_re, hex_literal_re,
-                      integer_literal_re, octal_literal_re]:
-            pos = self.pos
-            if self.match(regex):
-                while self.current_char in 'uUlLfF':
-                    self.pos += 1
-                return ASTNumberLiteral(self.definition[pos:self.pos])
-
-        string = self._parse_string()
-        if string is not None:
-            return ASTStringLiteral(string)
-
-        # character-literal
+              integer_literal_re, octal_literal_re]:
+    pos = self.pos
+    if self.match(regex):
+        # consume integer/float suffix characters (u, l, f, etc.)
+        while self.current_char in 'uUlLfF':
+            self.pos += 1
+        num_node = ASTNumberLiteral(self.definition[pos:self.pos])
+        pos_after_num = self.pos
+        if self.match(identifier_re):
+            return ASTUserDefinedLiteral(num_node, self.matched_text)
+        self.pos = pos_after_num
+        return num_node
+string = self._parse_string()
+if string is not None:
+    str_node = ASTStringLiteral(string)
+    pos_after_str = self.pos
+    if self.match(identifier_re):
+        return ASTUserDefinedLiteral(str_node, self.matched_text)
+    self.pos = pos_after_str
+    return str_node
+# character-literal
         if self.match(char_literal_re):
             prefix = self.last_match.group(1)  # may be None when no prefix
             data = self.last_match.group(2)